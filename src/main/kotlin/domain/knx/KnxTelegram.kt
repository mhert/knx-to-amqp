package domain.knx

import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encodeToString
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.Json
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter
import java.util.*

@Serializable
data class KnxTelegram(
    val source: String,
    val destination: String,
    @Serializable(with = OffsetDateTimeSerializer::class)
    val date: OffsetDateTime,
    @Serializable(with = ByteArrayToBase64Serializer::class)
    val data: ByteArray
) {
    /**
     * auto-generated by IntelliJ IDEA
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as KnxTelegram

        if (source != other.source) return false
        if (destination != other.destination) return false
        if (date != other.date) return false
        if (!data.contentEquals(other.data)) return false

        return true
    }
    /**
     * auto-generated by IntelliJ IDEA
     */
    override fun hashCode(): Int {
        var result = source.hashCode()
        result = 31 * result + destination.hashCode()
        result = 31 * result + date.hashCode()
        result = 31 * result + data.contentHashCode()
        return result
    }

    fun toJson(): String {
        return Json.encodeToString(this)
    }
}

object OffsetDateTimeSerializer: KSerializer<OffsetDateTime> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("ZonedDateTime", PrimitiveKind.STRING)

    override fun deserialize(decoder: Decoder): OffsetDateTime {
        return OffsetDateTime.parse(decoder.decodeString(), DateTimeFormatter.ISO_OFFSET_DATE_TIME)
    }

    override fun serialize(encoder: Encoder, value: OffsetDateTime) {
        encoder.encodeString(value.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME))
    }
}

object ByteArrayToBase64Serializer: KSerializer<ByteArray> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("ByteArrayToBase64", PrimitiveKind.STRING)

    override fun deserialize(decoder: Decoder): ByteArray {
        return Base64.getDecoder().decode(decoder.decodeString())
    }

    override fun serialize(encoder: Encoder, value: ByteArray) {
        encoder.encodeString(Base64.getEncoder().encodeToString(value))
    }
}
